// typeScript로 블록 생성 만들기

// 환경 설정 하고

// ts-node설치

// 설치 명령어
// -------------------------------------------------
// npm install -D typescript ts-node @types/node
// -------------------------------------------------

// tsconfig.json 만들기
// 설치 명령어
// -------------------------------
// tsc --init
// -------------------------------

// tsconfig.json에서 paths 사용할거라

// 설치 명령어
// -----------------------------------
// npm install -D tsconfig-paths
// -----------------------------------

// 우리가 필요한 모듈 설치

// 머클루트와 해시값이 필요하니깐
// crypto-js, merkle 설치

// 설치 명령어
// -----------------------------------
// npm install crypto-js merkle
// -----------------------------------

// typeScript는 외부 모듈을 사용할 경우에 타입 정의 파일이 필요하다.
// crypto-js, merkle 모듈 타입을 가져올 수 있는 모듈 설치

// 설치명령어
// -----------------------------------
// npm i --save-dev @types/crypto-js
// npm i --save-dev @types/merkle
// -----------------------------------

// 제네시스 블록 만들기

// 테스트 해보자

// 만들 것들 테스트 해보자

// typeScript로 블록체인을 만들었는데 객체지향적인 방법으로 코드를 작성하고 
// OOP(객체 지향 프로그래밍)

// OOP는 프로그램의 설계방법 개념의 하나이다.

// OOP는 프로그램을 단순히 실행 데이터 처리 방법만이 아니라 
// 수많은 객체라는 단위를 만들어서 이 객체를 가지고 동작하는 상호작용을 서술한 방식이다.
// OOP에서 객체는 하나의 역할을 수행하는 함수와 변수들의 묶음 데이터로 보면 된다.

// 이런 객체지향 프로그래밍은 프로그램을 만들 때 제일 작은 단위부터 만들어가는 방식을 선호함.
// 근데 그러면 작성된 코드들의 테스트가 어렵다는 단점이 있고 그래서 이런 부분 때문에 라이브러리를 사용해서
// 테스트 한다.

// 그냥 개발이 아니라 테스트 코드를 작성하면서 개발해 나가는게
// TDD(Test_Driven Development) 기법

// 그래서 우리도 테스트 해보려고 Jest라는 애를 써보자

// 설치 명령어
// -----------------------------------------------------------
// npm install -D ts-jest @types/jest babel-core
// npm install -D @babel/preset-typescript @babel/preset-env
// -----------------------------------------------------------


// 체인 만들기

// block 클래스로 만들 블록들을 체인으로 연결 시켜줄 chain을 클래스를 만들어보자.
// chain 클래스에는 생성한 블록을 배열로 담아서 블록체인을 만들 예정
// 이미 지금 우리가 만든 블록은 블록의 속성으로 체이닝 이미 이뤄지고 있는데
// 이전 블록 해시 값을 속성으로 가지고 있기 때문에 특정 블록 기준으로 이전 블록 해시 값이 달라지면
// 현재 블록의 이전 해시값과 불일치가 발생해서 연결 고리가 끊긴다.
// chain 클래스를 따로 만들어서 생성된 블록을 하나의 배열 안에 담아주는 역할을 할 예정

// 이렇게 하는 이유는 이후에 우리가 마이닝 할 때 난이도 계산을 하기 위해서.

// POW (Proof of Work :  작업증명)
// 작업 증명 역사
// 1993년 모니 나노어이 작업증명의 기본 개념을 고안했다.
// 1997년 영국의 암호학자인 애덤백의 해시캐시고 이후에 2009년 이 기술을
// 사토시 나카모토라는 사람이 비트코인에 적용이 되어 오늘 날까지 사용된다.

// 해시캐시는 대량으로 스팸메일을 방지하고자 고안된 것.
// 이메일을 보내기 위해서 작업증명 알고리즘을 이용해서 해시값을 찾고
// 그 보상으로 발행되는 우표 같은.
// 이 과정이 시간과 비용이 많이 들고 대량으로 발생되는 스팸메일을 막을 수 있는
// 방법으로 이 방식을 사용했다.

// 작업증명 방식을 거래가 발생하면 해당 거래가 유용한지에 대한 합의 검증 방식

// 논스값을 이제 사용하고 

// 간단히 설명

// 작업증명은 어려운 수학 문제 푸는 것 이라고 생각하고
// 채굴 하는데  작업증명을 하는 것이 채굴이다 라고 할 수 있다.
// 어려운 수학 문제를 풀게해서 이 문제를 푼 사람한테 보상으로 비트코인을 주는 것 .

// 여기서 특정 조건을 만족하는 논스 값을 찾는 것이다.

// 블록체인 삼의 모든 참여자는 동일한 순서로 블록을 연결하기 위해서
// 합의 알고리즘이 필요하고
// 대표적인 합의 알고리즘은 POW, POS, DPOS, POA등이 있다.

// 난이도가 4
// 논스 ???
// 0000이 4개 이상인 해시값이 나올 때 까지 목표값이 나올 때 까지
// 논스를 0에서 계속 하나씩 더하면서 해싱을 해서 목표값을 찾는 것
// 

// "작업증명 방식"은 POW는 목표값 이하의 해시 값을 찾는 과정을 무수히 반복해서
// 해당 작업에 참여했음을 증명하는 방식의 알고리즘.

// 작업증명 알고리즘의 필요성은 네트워크 상의 모든 노드가 동시에 블록을 만들 수 없게 하는 것.
// 작업증명을 통과해야만 새로운 블록을 추가 생성 할 수 있게 된다는 점

// 작업증명 알고리즘은 Difficulty 조절 알고리즘을 이용해서 약 10분당 1개의 블록이 생성 되는 것을 보장하게 된다.

// 난이도 저정 블록 범위 => 10
// 블록의 생성 시간 (단위 : 분) => 10
// 생성 시간 (단위 : 초) => 60

// Difficulty 조절 알고리즘은 다음과 같이 설계 하자

// 블록 한 개가 생성되는 예상 시간을 10분으로 설정하고, 10개의 블록을 한 묶음으로 해서 블록 한 묶음이 생성되는
// 예상시간을 6000초라는 값을 할당해주고 이후 10개의 블록이 생성되는데 걸리는 시간 timeExpected / 2보다 작을 경우
// 난이도 조절을 1 증가시키고 timeExpected * 2 보다 클 경우에는 난이도를 1 감소 시키자

// ㅗ ----20221102~03------

// ㅜ ----20221107------
// P2P 네트워크

// block 클래스랑 chain를 가지고
// P2P네트워크 http / ws 환경 구성

// http / ws 환경 구성

// p2p 네트워크를 만드는데 http와 ws 웹소켓을 사용해서
// api들을 구성하고 블록을 가져올 express 모듈로 서버 동작을 하고 P2P 네트워크를 웹소켓으로 구성

// 설치할 모듈

// 설치 명령어

// express와 express-type 설치
// -------------------------------------------------------
// npm install express
// npm install --save-dev @types/express
// -------------------------------------------------------

// ws 웹소켓 설치
// -------------------------------------------------------
// npm install ws
// npm install --save-dev @types/ws
// -------------------------------------------------------

// ----------1110-----------------------------------------
// 머클 트리란 머클 트리는 수많은 트랙잭션을 각각 해싱해서
// 2개의 짝 지어서 해싱을 계속 반복 해서 최종적으로 하나가 남을 때 까지 해싱한 트리
// 1. 첫번째 데이터를 SHA256형태의 해시값으로 변환
// 2. 2개의 노드를 한쌍으로 묶어서 해시값 변환
// 3. 해시값으로 변환을 반복해서 마지막 하나가 남을때 까지 반복
// 4. 블록의 모든 거래를 합친 해시값이 머클 루트
// 머클 트리가 필요한 이유는 머클 트리의 목적이
// 데이터의 간편성과 확실한 인증 이기 때문에 

// 블록체인 네트워크 정보를 모두 다운로드 하면 무척 용량이 크기 때문에
// 최소한의 정보로 인증하기 위해 블록체인을 전부 다운로드 하지 않고 
// 머클루트 값만 가진다. 

// SHA256알고리즘으로 256bit로 구성된 64자리 문자열로 암호화 해준다고 했고 머클루트 값은 64자 이고 안전하고 다양한 검증을 빠르게 할 수 있는 것 
// 머클 트리 자체가 해시로 이루어져 있고 하나의 트랜잭션이나
// 아니면 블록의 값이 변조 되면 머클루트 해시 값이 변조되고 
// 잘못된 해시값이 나오게 되면 해당 블록이 잘못된 것으로 블록을 거부하고 블록체인 네트워크를 안정적으로 유지할 수 있다. 

// 블록체인의 동작 방식
// 비트코인 지갑 설치 -> peer연결 -> 블록 다운로드 -> 블록의 검증(해시)

// 비트코인 지갑 생성
// Random 값을 만들고 -> 개인키와 공개키 생성(타원 곡선 알고리즘 사용 ECC) -> 지갑 주소 생성(SHA256&Bace58)

// 블록체인의 동작
// 브로드 캐스팅(알려준다 내가 새로운 거래를 만들었다라면)
// 1. 지갑 프로그램에 연결된 peerlist를 확인하고
// 2. 네트워크 브로드 캐스팅
// 3. 채굴 시작 (내가 먼저 다른 사람이 만든 거래를 승진(블록생성)을 해주고 수수료를 받아야지)
// 4. 채굴 성공 (내가 찾은 nonce를 모두에게 알린다.)
// 5. 채굴에 성공한 블록을 전달
// 6. 네트워크 브로드 캐스팅
// 7. 블록을 검증을 한 후 블록 체인에 연결
// 8. 룽기스트 블록 체인 


// P2P기술에서 P peer의 약자
// P2P는 서비스에서 모두가 서버가 될 수 있고 클라이언트가 될 수 있다.
// P2P는 서로 다른 사용자들끼리 자료를 주고 받는다라는 뜻
// Peer는 동등한 사용자를 의미

// 비트코인 화폐를 발행하는 방식이 마이닝이고 
// 비트코인 화폐는 10분에 한 번씩 일정량이 생성되며
// 마이닝에 참여한 사용자 중 한 명에게 지급된다.
// 참여자들은 hashcash라는 문제를 풀고. hashcash는 특정한 조건을 가지는 해시값을 찾는 것 


// 트랜잭션

// 블록이 생성될때 우리 데이터 부분에 블록 몇번재 이렇게 문자로 담았는데 
// 비트코인 네트워크 트랜잭션
// 블록이 생성될때 블록안에 data 안에 트랜잭션을 담아준다.

// 블록이 생성되면 data에 트랜잭션을 담아주는데 이게 첫번쨰 트랜잭션은 코인베이스 트랜잭션
// 이라고 부르고 내용은 마이닝을 했을때 얻는 보상의 내용이 들어간다.
// 블록을 채굴하고 채굴한 사람이 얼마나 코인을 보상받았는지.

// 트랜잭션 내용 안에 객체가 표현되어있고
// UnspentTransactionOutput (UTXO) 이 공간에 잔액을 객체로 저장
// 암호화폐에서 아직 사용 되지 않은 거래 출력 사용할 수 있게 승인된 일정량의 디지털 화폐
// 사용되지 않은 미사용 객체

// 첫 번째 트랜잭션 코인베이스 트랜잭션
// Tx 0000 = {
// input: {},
// output : {주소 : 누구, 얻은코인 : 50}
// }

// UTXO = [{주소: 누구, 얻은 코인 : 50, 참조 트랜잭션 : Tx 0000}]
// UTXO안에 있는 객체를 수정하는 것이 아니라 삭제하고 새로운 객체를 넣어주는 것 

// Tx 0001 = {
// input: {주소 : 누구, 코인 : 50, 참조 트랜잭션 : Tx 0000},
// output : {주소 : 너, 코인 : 1}, {주소 : 누구, 코인 : 49}
// }

// UTXO 에서 {주소: 누구, 얻은 코인 :50, 참조 트랜잭션 : Tx 0000}를 제거하고
// UTXO = [{주소: 너, 코인 : 1, 참조 트랜잭션 : Tx 0001},
//         {주소 : 누구, 코인 : 49, 참조 트랜잭션 : Tx 0001}]

// "누구"라는 사용자가 "너"에게 50코인에서 1코인을 보낸다고 가정해서 
// input에 Tx 0000 트랜잭션을 속성값으로 전달하고 output 에는 두 객체 {주소: 너, 코인 : 1, 참조 트랜잭션 : Tx 0001},
//   {주소 : 누구, 코인 : 49, 참조 트랜잭션 : Tx 0001} 객체가 만들어지고 이 두 객체를 통해서 만들어진 내용이 UTXO에 객체로 담기게 된다(미사용 객체)
// 사용된 객체는 제거

// Tx 0002 = {
// input: {주소 : 누구, 코인 : 49, 참조 트랜잭션 : Tx 0001},
// output : {주소 : 너, 코인 : 20}, {주소 : 누구, 코인 : 29}
// }

// UTXO = [{주소 : 너, 코인 : 1}, {주소 : 너, 코인 :20}, {주소 : 누구, 코인:29}]

// UTXO 라는 공간은트랜잭션의 내용을 구성해서 거래 내용을 기록해놓기 위함

// Tx 0003 = {
// input: {주소 : 누구, 코인 : 1, 참조 트랜잭션 : Tx 0001}, {주소 : 너, 코인 :20, 참조 트랜잭션 : Tx 0002}
// output : {주소 : 누구, 코인 : 21}, 
// }

// UTXO = [{주소 : 누구, 코인 : 29, 참조 트랜잭션: Tx 0002}, {주소 : 누구, 코인 : 21, 참조 트랜잭션 : Tx 0003}]


