/*
    트랜잭션과 미사용 트랜잭션 출력값인 UTXO에 대하여
    UTXO란? 미사용 트랜잭션 출력값
    - 일반 트랜잭션과 완전히 다름!                                      
    기존의 은행 : 트랜잭션이 발생하면 한번 트랜잭션을 발송하고 기록된다.
    하지만 비트코인에서는 트랜잭션이 발생된 후에도 해당 트랜잭션의 UTXO가 다른 트랜잭션을 만들때 까지 기록하지 않는다

        ex) 
        ---- UTXO 리스트-----
           다른사람이 나에게 송금함 
         /   A -> 0.1 BTC
         /   B -> 0.3 BTC
         /   C -> 0.6 BTC
         /   D -> 0.7 BTC
         ------------------------------------------------
            일단 송금받은 이 정보들은 모두 아직 UTXO이다. 아직 내 지갑에 들어오지 않았음

            이 상황에서 내가 0.5 BTC 가격의 자전거를 사려고 한다. 이때 또 트랜잭션이 발생하는데
            이 트랜잭션에서 사용할 것을 선택하게 된다. C가 송금한 0.6BTC를 선택하게 됨

            BUT!!!! 입력값에 들어간 BTC는 모두 사용되어야 한다!!! 모든 참가자에게 전송 가능
            0.5BTC 짜리를 0.6BTC주고 사야 한다는게 아니라

            0.5 BTC는 자전거를 구매하기위해 송금하고 나머지 0.1 BTC는 내 지갑으로 송금하게 된다.

            이렇게 되면 C 가 나에게 0.6 BTC원을 송금한 트랜잭션이 UTXO가 아니게 된다.

            거래 후
        ---- UTXO 리스트-----
           다른사람이 나에게 송금함 
            A -> 0.1 BTC
            B -> 0.3 BTC
        
            D -> 0.7 BTC
            Me -> Me 0.1 BTC
         ------------------------------------------------

         UTXO에서 사용할 트랜잭션을 선택하고 새로운 트랜잭션에 적용해(거래로 인해 발생하는 트랜잭션)  
         내 UTXO에서 사라지고 이 트랜잭션(거래)의 결과로 거래 대상(자전거 판매자)은 블록체인에 들어갈 UTXO를 얻게 된다.

         UTXO는 결국 잔고이자 미사용 트랜잭션 출력값인 거!
    ===========================================================================================================


        트랜잭션 수수료의 출처

        ex)
         ---- UTXO 리스트-----
           다른사람이 나에게 송금함 
            A -> 0.1 BTC
            B -> 0.1 BTC
            D -> 0.4 BTC
            E -> 0.3 BTC
            B -> 0.3 BTC
         ----------------------------
         ** B가 돈을 두번 송금했지만 하나의 UTXO로 처리되지 않고 별개의 트랜잭션으로 처리 되었음
         
         0.9BTC 원의 자전거와 0.02BTC 사과를 구매하고 싶다.
         한 트랜잭션은 자전거 가게와 한 트랜잭션은 과일가게와 이루어져야한다.
         이런 거래를 블록체인은 하나의 트랜잭션으로 처리할 수 있다!

         이어서 0.92BTC가 필요한 상황에서 내 UTXO 중에서
            D -> 0.4 BTC
            E -> 0.3 BTC
            B -> 0.3 BTC
        --------------을 가져와 거래에 쓴다면?
        입력값은 1 BTC이 되고
        출력값 : 0.9 BTC는 자전거 가게에
                 0.02 BTC는 사과에
                 지불하고 남은 0.06BTC 는 다시 나에게 보낸다
                 ====================> 세개의 트랜잭션이 하나의 새로운 트랜잭션에 들어가고 기존의 트랜잭션은 내 UTXO에서 사라진다.
                 그리고 처리되지 않은 0.02BTC는 트랜잭션의 수수료가 되어 블록체인에 포함됩니다. 이론적으로 블록체인이 무료라고는 하지만
                 채굴되어야하는 트랜잭션들이 멤풀에 많이 있기 때문에(경쟁상태)
                 트랜잭션이 수용되게 하려면 수수료를 지불해야한다. 수수료가 높을 수록 트랜잭션이 수용될 가능성이 높아진다.
                 그리고 수수료를 지정하는 필드는 따로 없고 자동으로 계산된다.(총 입력값 - 총 출력값)

*/

/*
    지갑의 작동원리
    - 지갑이 잔고를 도출하는 원리는 무엇일까?
        지갑은 사용가능한 UTXO를 계산하고 그것을 잔고라고 부르는 것이다.
        지갑은 연결 방식을 볼 수 있기 때문에 결과값을 도출하는 트랜잭션을 일단 모두 훑어 분석한다.
        그다음 미사용 트랜잭션 출력값(UTXO)가 있는지 확인한다. 그다음 UTXO들을 합산한다.
        하지만 이 잔고가 실제로 저장된 곳은 없다. 암호화폐에는 코인이 없기 때문이다.
        즉 실제로 기존의 은행시스템처럼 실제로 돈이 존재하거나 은행 전자원장이나 계좌에 정말 돈이 있다는 뜻이고
        지갑은 편의를 위한 것이다.
*/

/*
    서명 및 공개키
    트랜잭션을 보면 누가 어디에 송금을 했는지 얼마를 거래했는지 명확히 알 수 있다.
    
    개인키 :
     - 암호화폐를 시작하면 개인키가 할당된다. 고유 식별자같은 것으로 이는 은행계좌의 비밀번호와 같은 개념이다.

     공개키:
     - 개인키로 만들 수 있다. 공개키는 다른 사람과 주고 받을 수 있다. 은행계좌 번호 같은것으로 돈을 보낼때 다른 사람과 공유할 수 있음

     ex)
     A -> B 0.7BTC을 송금한다. 이때 개인키와 메세지가 결합해 서명을 생성한다. 개인키는 메세지 서명에 사용되고 소유자의 고유한 서명이 되는 것이다.
     그래서 누구라도 해당 메세지를 접하면 해당 서명도 접하게된다.

     이때 서명이 누가 만든 것인지 어떻게 알 수 있을까?
     - 바로 공개키를 사용하면 된다. 블록체인 알고리즘에는 검증함수가 있다! 해당 트랜잭션의 메세지와 서명 그리고 
     (해당 서명의 개인키로 만든)공개키를 검증함수에 넣으면 예 /아니오를 도출할 수 있다.
     즉 공개키를 통해 서명과 메세지의 결합을 평가해 개인키로 메세지에 서명을 했는지 검증할 수 있다.

     검증함수의 실행 결과에 따라 블록체인에 트랜잭션을 보낼때 해당 트랜잭션을 블록체인에 넣거나 멤풀에 넣을지 결정할 수 있다.

     +) 데모 연습해볼 수 있는곳
     https://tools.superdatascience.com/blockchain/public-private-keys/keys

     
     공개키의 길이는 늘 고정이며 16진수이다.


     트랜잭션의 메세지, 공개키, 서명으로 검증할 수 있다.
*/

/*
    +) 블록 1개의 최대 크기는 1MB이다. 
    크기가 너무 작으면 많은 트랜잭션을 포함할 수 없고 대역폭문제가 생길 수 있다.
    크기가 크면 네트워크의 속도가 느려져 본 체인의 공유가 느려질 것이고, 
    고아블록이 생길 가능성이 높아지고 공격자가 접근해 공격하기도 용이해진다.

    분리된 증인(Segregated Witness)이란?
    - 

    - 블록체인의 속도가 느려지기 시작했고 트랜잭션 백로그가 발생하기 시작
    문제해결 방법 2가지
    하드포크 접근방법 : 블록하나의 크기를 키우는것. 비트코인 캐시

    소프트 포크 접근방법 : ***세그윗. 블록체인의 작동방식을 바꾸는 것으로 모든 구성원이 고려해야할 것은 아니다.
        어차피 시간이 지나면서 네트워크를 통해 전파 될 것이기 때문.
        -> 개별 트랜잭션의 콘텐츠를 확인한다.
            +) 트랜잭션에 포함된 내용 : from(주소), to, amount, <서명, 공개키>- 이 두개가 트랜잭션 크기의 60%를 차지한다.
        scritSig라는 자체 메시징 서비스와 네트워크를 통해 커다란 부분을 도려내고 전송하도록 해 더 많은 트랜잭션을 포함할 수 있게 했다.
        그래서 서명과 공개키 부분은 각 블록과 트랜잭션에 여전히 연결되어있지만 네트워크는 개별적으로 통과한다.
        (?? 근데 이러면 연결을 해킹할 수 도 있지 않을까? 송금받는 트랜잭션에 대해 대상을 나로 바꾼다면?)
    
        이때 세그윗 유형의 블록이 나타남!
        블록자체의 크기(1MB)는 커지지 않았지만 서명을 분리했기때문에 그만큼 더 많은 트랜잭션을 담을 수 있어
        용량이 커졌다고 느끼는 것이다
*/

/*
    공개키와 비트코인 주소
    비트코인 주소는 공개키에서 얻을 수 있고 한공개키에서는 같은 주소값을 얻는다.
    여기서 주소는 돈을 보내달라고 요청할 수 있는 주소이다. 그리고 비트코인을 바로 공개키로 보낼 수 도 있다.
    공개키나 주소로 송금하면 지갑에서 알아서 처리를한다
    그렇다면 주소는 왜 필요할까?
    - 공개키가 너무 자주 노출되지 않게 보호한다!
    누군가에게 비트코인이나 돈을 보낼때 트랜잭션이 유효한지 확인할 검증함수를 실행시키기 위해 공개키가 반드시 필요하다.

    그러나 돈을 받을 때는 공개키 노출을 방지해야한다
    왜?
    만약 개인키-공개키의 연결이 역설계되었거나 타원 함수의 결함이 밝혀지게 되면 공개키를 갖고 개인키를 알아낼 수 있기 때문이다.
    - 개인키와 공개키는 연결되어있다. 타원함수(SHA256원리의 핵심)

    개인키-(타원함수)-공개키-(SHA256)-주소 이런 구조이다.
    돈을 보내지 않는한 공개키에 빨리 접근할 수 없게 해준다.
    그래서 주소를 얻기위해 추가 해시또는 추가 SHA256을 적용한다.


    돈을 누군가 보낼때
    A가 B에게 송금할때 : B의 주소를 A에게 보내고 A는 트랜잭션에 주소를 입력한다. 그리고 이 트랜잭션이 블록에 들어갈때 A의 공개키와 함께 블록에 들어간다(메세지, 공개키, 서명).
*/

/*
    계층 결정적 지갑
    송금할때마다 공개키가 담긴 트랜잭션을 보내기 때문에 해당주소가 누구인지까지는 몰라도 대략적인 추이는 관찰 가능할 것이다. 예를 들어 방문 빈도 등
    
    현재의 해결 방법으로는 여러 개인키를 만들고 그만큼 공개키와 주소를 만들었다. 매번 새로운 개인키를 만들어 새로운 주소를 만들기도 했는데 번거로움

    Bip32 라는 기술을 선보임
    - HD지갑을 통해 마스터 개인키를 만들 수 있다.
    해당 마스터키로 개인키를 생성할 수 있다. 그리고 어떤 키를 만들었는지 지갑이 관리해주기 때문에 따로 기억하지않아도 된다.
    그리고 각 개인키를 개별로 관리하기 때문에 각 개인키로만 계정이 연결되어있어서 다른 키에서 어떤 트랜잭션을 생성했는지 알 수 없다.


    +) 마스터 공개키
     마스터 공개키를 통해서 개인키를 생성할 수는 없다. 하지만 모든 공개키를 다시 만들 수는 있다.

     이런 것은 감사인과 같이 트랜잭션을 발생시킬 필요가 없는 대상에게 부여한다
     
     니모닉 : 영문자에서 특정 12자를 뽑아서 만든 조합이기때문에 동일한 마스터키를 받을 확률이 극히 적다. 
     니모닉이 있으면 개인의 마스터 키를 생성할 수 있기 때문에 보관에 유의
*/

/*
- 수수료는 어디서 나오는가?
    트랜잭션 수수료는 트랜잭션의 입력값과 출력값의 차이이다. 채굴자는 미사용된 것을 모두 받으며, 이용자는 이런식으로 지불하고자 하는 수수료를 선택할 수 있다.
- 공개키와 주소의 차이점?
    둘은 거의 같다 주소는 공개키이며 SHA256의 암호화된 버전이다. 타원곡선이 해킹된 경우 추가적인 보안을 위해 수행된다.
*/