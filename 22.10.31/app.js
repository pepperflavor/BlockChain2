// 비트코인 백서
// 비트코인은 개인대 개인 전자 화폐 시스템이고

/*  P2P란 peer to peer 로서 인터넷에서 개인과 개인이 직접 연결되어 
    파일을 공유하는 것을 이야기한다. 
    개인과 개인간에서 전자화폐 송금 시스템을 제안한다.
    satosi Nakmoto(사토시 나카모토) 누구인지 밝혀지지 않음...
    개발자이기 전에 경제학으로도 지식을 가지고 있었을 것으로 추측됨
*/

/*
    개인 대 개인 버전, 전자화폐는 금융기관을 거치지 않고 한쪽에서
    다른 쪽으로 직접 전달되는 온라인 결제를 실현한다.(우리가 사용하고 있는 금융 시스템은 금융기관을 통해서만 한쪽에서 다른쪽으로 직접 전달되는 온라인 지불)
    오프라인에서는 직접 우리가 현금을 지불하면 다른사람한테 직접 전달이 가능한데 온라인 같은 경우는 개인과 개인간에서 구축된 시스템을 거치지 않는 이상 존재하지 않는다.
    비트코인은 어떤 중앙 기관없이 내가 가진 자산을 다른 사람에게 전달 할 수 있는 시스템을 구현한다고 보면된다.
*/

/*  
    어떤 문제점이 있었나? 온라인 전자 서명 시스템은 적용되어있고 이중지불을 막기위해
    신뢰할 수 있는 제 3자가 필요한데. 이중지불 문제 해결의 솔루션을 제안한다
*/

/*   
    전자서명만 사용할 떄는 이중지불을 막을 수 가 없기 때문에 우리는 일반적으로 중앙화된 기관이 필요한데 중앙화된 기관 없이 이중지불 문제 해결의 솔루션을 제안하는 것
    이중 지불을 막기 위해서 거래 내용을 해싱하고 타밍 스템프를 찍어서 해시 기반 작업 증명을 연결한 사슬로 만들고 작업증명을 재 수행하지 않으면 변경할 수 없는 기반작업을 만든다
*/

/*  
    일반적으로 우리가 알고 있는 블록체인이란 단어가 여기서 나온다. 연결한 사슬이라는 것, 블록들을 체인 형태로 연결한 형태를 타임스템프를 찍어서 기록한 것, 블록체인이라는 데이터 들을 안전하게 위변조가 되지 않게 해시 기반 작업 증명을 통해서 블록체인이 안전하게 보관이 되고 생성이 되었다는 것을 증명할 수 있는 기반이 된 것
*/

// 가장 긴 사슬 : 개인 대 개인간의 네트워크이고 중앙 기관이 없다보니 체인이 여러개로 나누어지기 때문에 가장 긴 체인을 선택한다 : "Longest chain Rule"(롱기스트 체인 룰)과 연관이 있다. 롱기스트 체인 룰을 통해서 중앙화된 기관없이 항상 하나의 체인을 유지 할 수 있는 기반을 만들었다.

/*
    2008년 비트코인이 처음 출시 됐을때 사토시 나카모토가 생각했던 내용은 개인대 개인 네트워크에 참여하는 사용자들은 일반적으로 집에서 PC를 사용해서 네트워크에 참여할 거라고 생각했고 네트워크에 참여하는 사람들이 작업 증명을 사용할 때는 자신의 PC의 CPU를 통해서 작업을 진행하기 때문에 CPU 파워풀이라고 이야기 했지만 실제로 비트코인 네트워크가 역사적으로 발전하면서 채굴풀이라는 개념도 등장했고 전문 채굴기들도 등장하면서 전문 채굴기들이 사용할 공통 용어가 필요해 졌고 지금은 CPU 파워가 아니라 해시레이트라고 부르고 있다.
*/

/*  
사카시 나카모토는 2008년 금융위기를 보며 현재 우리가 신뢰하는 중앙기관이 실제로는 신뢰하기 어려운 기관이라 생각했고 비트코인을 제안하게 되었다.

왜 비트코인을 처음 알아야할까?
비트코인이 블록체인에서 가지고 있어야 할 철학적 경제적 기술적 특성을 모두 잘 포함하고 있기 때문에 블록체인에서 가장 중요한 철학 탈중앙화 Decentralize(디센트럴 라이즈) 블록체인의 모든 기술개발은 항상 중앙화된 기관을 없애려고 노력하는 형태
실제로 코어를 개발하고 운용하는 사람들은 중앙화된 거래소나 중앙화된 서비스들을 어떻게 하면 탈중앙화 할까 노력하고 기관들 없이 거래할 수 있는 방안들의 개발을 진행하고 있다.
*/

/* 블록체인의 4대 요소 기술

    1. 블록과 트랜잭션 : 트랜잭션은 사용자의 송금내역이고 송금내역들을 하나의 블로에 포함시켜야 하지만 안정성을 보장할 수 있는 기반을 만들 수 있다. 그 블록들이 해시 알고리즘과 POW를 통해서 연결하는 형태가 블록체인

    2. 분산 네트워크 : 사용자들이 언제든지 네트워크에 참여할 수 있고 나갈 수 있는 것이 분산네트워크이다.

    3. 암호화 : 본인 증명뿐만 아니라 거래가 위변조 되지 않았다고 증명할 수 있다.
    4. 합의 알고리즘 : 분산네트워크에서 중앙화된 기관이 없으니까 하나의 체인을 구성하는 것이 매우 중요하고 그리고 모든 분산화된 네트워크에서 모든 사용자들이 납득할 수 있는 하나의 거래내역이 필요한데 이걸 하나로 정리해주는 것이 합의 알고리즘이다.
    합의 알고리즘은 일반적으로 POW만 부르는데 POW와 롱기스트 체인 툴을 포함하여 실제로 네트워크 기준으로 하나의 체인 유지를 할 수 있다.

    POW : (Proof of work) : 스펨메일을 방지하고자 고안된 암호화폐이다. 이메일을 보내기 위해 작업증명 알고리즘을 이용해서 해시값을 찾은 것
*/

// 블록의 구성 : 블록은 특정 정보들을 담아놓은 객체라고 보시면 됩니다.

/*  블록은 영역 Header, Body로 나눠져 있고 구분하기 위해
    Header
    1. 버전정보
    2. 이전 블록의 해시
    3. 몇번째 블록인지의 정보(높이)
    4. 블록의 생성시간의 정보(타임 스탬프)
    5. 블록의 해시
    6. Body의 내용을 해싱한 값.(머클루트)
    7. 채굴의 난이도
    8. 논스
*/

// Body
/*
    블록에 대한 이해를 좀 쉽게 하기위해서 Header, Body라고 구분했을 뿐 헤더영역과 바디 영역을 구분지어서 블록생성하진 않는다

    자바스크립트 객체로 만들어보자
*/

const Block ={
    version : '1.0.0', // 블록의 버전 소프트웨어 / 프로토 버전
    previousHash : '',// 이전 블록의 해시
    height : 0, // 블록체인에 연결된 블록의 수 블록이 생성된 순서는 높이로 표현한다
    hash : '', // 해시 특정 블록을 식별할 때 고유 식별자로 해시값을 사용한다
    // 해시값은 블록의 생성일, 버전, 비츠 머클루트, 이전 블록의 해시, 논스라 불리는 임시값 등등 조합해서 해시로 변환해서 생성
    merkleRoot : '', // block body의 내용을 해싱한 값 2진 트리 형태
    // 머클루트는 블록의 트랜젝션에 대한 내용이 저장되어있고, 트랜젝션의 내용들을 해싱해서 해시값으로 만든 트리구조가 머클 트리라고 한다. 머클트리의 루트에 대한 해시 값이 머클루트
    bits : '', // 비츠 난이도 조절용 수치
    difficulty : '', // 채굴 난이도
    nonce : '', // 논스는 최초에 0에서부터 시작해서 조건이 만족하는 해쉬값을 찾을때 까지 1씩 증가하는 계산횟수
    data : ['asdasd'] // block body 내용 트랜젝션의 내용이 블록안에 데이터로 저장된다.
}

/*
    블록체인의 거래정보 변경이 불가능한 이유

    거래 정보의 해시값을 거래가 포함된 블록의 머클루트 계산에 입력값으로 사용되고 머클루트는 블록 해시의 계산 입력 값으로 사용된다.
    A블록이랑 B블록 있다
    A블록의 해시는 다음 B블록의 previousHash(이전 블록의 해시) 값에 저장되고 previousHash는 A블록의헤더 정보이고 블록해시를 계산하기위한 값으로 사용된다.
    그렇기 때문에 거래정보가 변경되면 머클루트가 변경되고 머클루트가 변경이 되면 블록해시가 변경되어서 블록해시의 변경은 다음 블록 해시 변경으로 연쇄적으로 이어지게 된다.
*/

/*
    거래정보 변경 -> 머클루트 변경 -> 머클루트 변경으로 블록해시 변경 -> 블록해시는 논스값을 찾아 작업이 증명이 되야 구할 수 있기 때문에 거래정보를 변경한 블록부터 그 이후의 모든 블록을 순서대로 다시 채굴해야한다.
*/

/*
    완료된 거래 정보를 변경하려면 변경하려는 거래 정보가 있는 블록부터 그 이후의 모든 블록을 순서대로 다시 채굴해야하기 때문에 시간이 무척 많이 걸리고 그동안 다른 노드들에 의해서 블록이 계속 추가되어 완료된 거래 정보의 변경은 현실적으로 불가능하다. 
*/

/*
    작업 증명 POW()
    새로운 블록을 블록체인에 추가하려는 작업을 완료한 것을 증명하는 것 새 블록을 블록체이넹 추가하려면 블로그이 블록 해시를 계산해야하고 블록해시의 계산은 블록 해더 정보의 논스값을 계산해서 구한다.
    논스 값을 구하는게 작업증명이다.
*/

// 자바스크립트로 만들자
/* 
    블록의 해시 값과 머클루트 값을 Crypto-js와 merkle 라이브러리르 쓸거고 블록의 해시 값과 머클루트 값이 어떻게 생성되는지 한번 구조를 보자
*/
/*
    설치명령어
    ==============================================
        npm i crypto-js merkle
    ==============================================
*/